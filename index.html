<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Wins Tracker</title>
    <!-- React & Babel -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.321.0/dist/umd/lucide.min.js"></script>
    <!-- Confetti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: black; color: white; margin: 0; overflow-x: hidden; }
        .glass { backdrop-filter: blur(16px); background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); }
        #root:empty { background: black; min-height: 100vh; }
        .win-card { transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .win-card:active { transform: scale(0.95); }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // More robust Icon component that uses Lucide CreateElement
        const Icon = ({ name, size = 24, className = "" }) => {
            const [iconHtml, setIconHtml] = useState("");

            useEffect(() => {
                const updateIcon = () => {
                    if (window.lucide) {
                        const iconName = name.charAt(0).toLowerCase() + name.slice(1);
                        // Using createSVGElement or simply replace method is safer in browser UMD
                        const iconData = window.lucide.icons[name] || window.lucide.icons[name.charAt(0).toUpperCase() + name.slice(1)] || window.lucide.icons.Zap;
                        
                        if (iconData) {
                            // Convert internal icon representation to SVG string
                            const attrs = {
                                xmlns: "http://www.w3.org/2000/svg",
                                width: size,
                                height: size,
                                viewBox: "0 0 24 24",
                                fill: "none",
                                stroke: "currentColor",
                                strokeWidth: "2",
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                class: `lucide lucide-${name.toLowerCase()} ${className}`
                            };
                            
                            const attrString = Object.entries(attrs).map(([k, v]) => `${k}="${v}"`).join(' ');
                            const content = iconData[1].map(tag => {
                                const [tagName, tagAttrs] = tag;
                                const innerAttrs = Object.entries(tagAttrs).map(([k, v]) => `${k}="${v}"`).join(' ');
                                return `<${tagName} ${innerAttrs}></${tagName}>`;
                            }).join('');
                            
                            setIconHtml(`<svg ${attrString}>${content}</svg>`);
                        }
                    }
                };

                updateIcon();
                if (!window.lucide) {
                    const check = setInterval(() => { if (window.lucide) { updateIcon(); clearInterval(check); } }, 50);
                    return () => clearInterval(check);
                }
            }, [name, size, className]);

            return <span style={{ display: 'inline-flex' }} dangerouslySetInnerHTML={{ __html: iconHtml }} />;
        };

        const DAYS_OF_WEEK = [
            { label: 'M', value: 1 }, { label: 'T', value: 2 }, { label: 'W', value: 3 },
            { label: 'T', value: 4 }, { label: 'F', value: 5 }, { label: 'S', value: 6 }, { label: 'S', value: 0 },
        ];

        const App = () => {
            const [habits, setHabits] = useState(() => {
                const saved = localStorage.getItem('wins_v10');
                return saved ? JSON.parse(saved) : [
                    { id: '1', name: 'Morning Sunlight', groupId: 'morning', schedule: [0, 1, 2, 3, 4, 5, 6], completedDays: {} },
                    { id: '2', name: 'Deep Work Session', groupId: 'work', schedule: [1, 2, 3, 4, 5], completedDays: {} },
                ];
            });

            const [groups, setGroups] = useState(() => {
                const saved = localStorage.getItem('wins_groups_v10');
                return saved ? JSON.parse(saved) : [
                    { id: 'morning', name: 'Foundation' },
                    { id: 'work', name: 'Productivity' },
                ];
            });

            const [isHabitModalOpen, setIsHabitModalOpen] = useState(false);
            const [isGroupModalOpen, setIsGroupModalOpen] = useState(false);
            const [newHabitName, setNewHabitName] = useState('');
            const [newGroupName, setNewGroupName] = useState('');

            const todayKey = new Date().toISOString().split('T')[0];
            const todayDayIndex = new Date().getDay();

            useEffect(() => {
                localStorage.setItem('wins_v10', JSON.stringify(habits));
                localStorage.setItem('wins_groups_v10', JSON.stringify(groups));
            }, [habits, groups]);

            const habitsDueToday = useMemo(() => habits.filter(h => h.schedule.includes(todayDayIndex)), [habits, todayDayIndex]);
            const dailyProgress = useMemo(() => {
                if (habitsDueToday.length === 0) return 0;
                const done = habitsDueToday.filter(h => h.completedDays[todayKey]).length;
                return Math.round((done / habitsDueToday.length) * 100);
            }, [habitsDueToday, todayKey]);

            useEffect(()
